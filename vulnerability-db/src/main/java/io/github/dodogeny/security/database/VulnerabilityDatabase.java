package io.github.dodogeny.security.database;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import io.github.dodogeny.security.model.ScanResult;
import io.github.dodogeny.security.model.Vulnerability;
import org.flywaydb.core.Flyway;
import org.slf4j.Logger;

import javax.sql.DataSource;
import java.io.File;
import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * High-performance vulnerability database with concurrent processing and caching
 */
public class VulnerabilityDatabase {
    
    private final DatabaseConfig config;
    private final Logger log;
    private final DataSource dataSource;
    private final ObjectMapper objectMapper;
    private final ExecutorService executorService;
    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    
    public VulnerabilityDatabase(DatabaseConfig config, Logger log) {
        this.config = config;
        this.log = log;
        this.objectMapper = new ObjectMapper();
        this.objectMapper.registerModule(new JavaTimeModule());
        this.executorService = Executors.newFixedThreadPool(4); // For parallel processing
        this.dataSource = createDataSource();
    }
    
    public void initialize() throws SQLException {
        log.info("Initializing Bastion vulnerability database...");
        runMigrations();
        // createIndexesAndOptimize(); // Disabled - indexes are created via migration scripts
    }
    
    private DataSource createDataSource() {
        try {
            String jdbcUrl = buildJdbcUrl();
            log.info("Initializing {} vulnerability database: {}", config.getType().toUpperCase(), 
                    config.getType().equals("h2") ? config.getPath() : config.getUrl());
            return new PerformantDataSource(jdbcUrl, config.getUsername(), config.getPassword());
        } catch (SQLException e) {
            throw new RuntimeException("Failed to create data source", e);
        }
    }
    
    private String buildJdbcUrl() throws SQLException {
        switch (config.getType().toLowerCase()) {
            case "h2":
                String dbPath = config.getPath() != null ? config.getPath() : 
                    new File(System.getProperty("user.home"), ".m2/bastion-security-cache/vulnerability").getAbsolutePath();
                
                // Only create directories for file-based databases, not for in-memory databases
                if (!dbPath.startsWith("mem:")) {
                    File dbFile = new File(dbPath);
                    File parentDir = dbFile.getParentFile();
                    if (parentDir != null && !parentDir.exists() && !parentDir.mkdirs()) {
                        throw new SQLException("Failed to create database directory: " + parentDir.getAbsolutePath());
                    }
                }
                
                // Use different settings for in-memory vs file-based databases
                if (dbPath.startsWith("mem:")) {
                    // In-memory database - simpler settings
                    return "jdbc:h2:" + dbPath + ";DB_CLOSE_DELAY=-1;MODE=PostgreSQL;" +
                           "DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH";
                } else {
                    // File-based database - full settings
                    return "jdbc:h2:" + dbPath + ";MODE=PostgreSQL;" +
                           "DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH;CACHE_SIZE=32768";
                }
                
            case "postgresql":
            case "postgres":
                return config.getUrl() != null ? config.getUrl() : 
                    "jdbc:postgresql://localhost:5432/bastion_security_db";
                
            case "mysql":
                return config.getUrl() != null ? config.getUrl() : 
                    "jdbc:mysql://localhost:3306/bastion_security_db";
                
            default:
                throw new SQLException("Unsupported database type: " + config.getType());
        }
    }
    
    private void runMigrations() {
        try {
            Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .locations("classpath:db/migration")
                .baselineOnMigrate(true)
                .validateOnMigrate(false)
                .load();
            
            flyway.migrate();
            log.info("Database migrations completed successfully");
            
        } catch (Exception e) {
            log.error("Database migration failed", e);
            throw new RuntimeException("Database migration failed", e);
        }
    }
    
    private void createIndexesAndOptimize() throws SQLException {
        if ("h2".equals(config.getType().toLowerCase())) {
            try (Connection conn = dataSource.getConnection(); 
                 Statement stmt = conn.createStatement()) {
                
                // Create indexes for performance
                stmt.execute("CREATE INDEX IF NOT EXISTS idx_vulnerabilities_cve ON vulnerabilities(cve_id)");
                stmt.execute("CREATE INDEX IF NOT EXISTS idx_vulnerabilities_severity ON vulnerabilities(severity)");
                stmt.execute("CREATE INDEX IF NOT EXISTS idx_scan_sessions_project ON scan_sessions(project_id)");
                stmt.execute("CREATE INDEX IF NOT EXISTS idx_scan_dependencies_session ON scan_dependencies(scan_session_id)");
                stmt.execute("CREATE INDEX IF NOT EXISTS idx_scan_vulnerabilities_dependency ON scan_vulnerabilities(dependency_id)");
                
                // Analyze tables for query optimization
                stmt.execute("ANALYZE");
                
                log.info("Database indexes created and optimization completed");
            }
        }
    }
    
    public void storeScanResultBatch(ScanResult result) throws SQLException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            
            try {
                Long projectId = storeProject(conn, result);
                Long scanSessionId = createScanSession(conn, projectId, result);
                
                // Use batch processing for dependencies
                storeDependenciesBatch(conn, scanSessionId, result);
                
                updateScanSession(conn, scanSessionId, result);
                conn.commit();
                
                log.info("Scan result stored with session ID: {} ({} dependencies processed)", 
                        scanSessionId, result.getDependencies().size());
                
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        }
    }
    
    private void storeDependenciesBatch(Connection conn, Long scanSessionId, ScanResult result) throws SQLException {
        String depSql = "INSERT INTO scan_dependencies (scan_session_id, group_id, artifact_id, version, " +
                       "scope, is_direct, file_path, sha1_hash, sha256_hash, file_size) " +
                       "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        
        String vulnSql = "INSERT INTO scan_vulnerabilities (scan_session_id, dependency_id, vulnerability_id, " +
                        "confidence, evidence) VALUES (?, ?, ?, ?, ?)";
        
        try (PreparedStatement depStmt = conn.prepareStatement(depSql, Statement.RETURN_GENERATED_KEYS);
             PreparedStatement vulnStmt = conn.prepareStatement(vulnSql)) {
            
            int batchCount = 0;
            final int BATCH_SIZE = 100;
            
            for (ScanResult.DependencyResult dep : result.getDependencies()) {
                depStmt.setLong(1, scanSessionId);
                depStmt.setString(2, dep.getGroupId());
                depStmt.setString(3, dep.getArtifactId());
                depStmt.setString(4, dep.getVersion());
                depStmt.setString(5, dep.getScope());
                depStmt.setBoolean(6, dep.isDirect());
                depStmt.setString(7, dep.getFilePath());
                depStmt.setString(8, dep.getSha1Hash());
                depStmt.setString(9, dep.getSha256Hash());
                depStmt.setObject(10, dep.getFileSize());
                depStmt.addBatch();
                
                if (++batchCount % BATCH_SIZE == 0) {
                    int[] results = depStmt.executeBatch();
                    processVulnerabilities(depStmt, vulnStmt, scanSessionId, 
                                         Arrays.copyOfRange(result.getDependencies().toArray(new ScanResult.DependencyResult[0]), 
                                                           batchCount - BATCH_SIZE, batchCount), results);
                }
            }
            
            if (batchCount % BATCH_SIZE != 0) {
                int[] results = depStmt.executeBatch();
                processVulnerabilities(depStmt, vulnStmt, scanSessionId,
                                     Arrays.copyOfRange(result.getDependencies().toArray(new ScanResult.DependencyResult[0]),
                                                       (batchCount / BATCH_SIZE) * BATCH_SIZE, batchCount), results);
            }
            
            vulnStmt.executeBatch();
        }
    }
    
    private void processVulnerabilities(PreparedStatement depStmt, PreparedStatement vulnStmt, 
                                      Long scanSessionId, ScanResult.DependencyResult[] dependencies, 
                                      int[] results) throws SQLException {
        
        try (ResultSet rs = depStmt.getGeneratedKeys()) {
            int idx = 0;
            while (rs.next() && idx < dependencies.length) {
                Long dependencyId = rs.getLong(1);
                ScanResult.DependencyResult dep = dependencies[idx++];
                
                for (String vulnerabilityId : dep.getVulnerabilityIds()) {
                    vulnStmt.setLong(1, scanSessionId);
                    vulnStmt.setLong(2, dependencyId);
                    vulnStmt.setString(3, vulnerabilityId);
                    vulnStmt.setString(4, "HIGH");
                    vulnStmt.setString(5, "Detected by Bastion scanner");
                    vulnStmt.addBatch();
                }
            }
        }
    }
    
    // Multi-module and mono-repo support methods
    public List<ScanResult.ScanSummary> getMultiModuleScanHistory(String rootGroupId, int limit) throws SQLException {
        String sql = "SELECT ss.*, p.group_id, p.artifact_id, p.version, p.name " +
                    "FROM scan_sessions ss " +
                    "JOIN projects p ON ss.project_id = p.id " +
                    "WHERE p.group_id LIKE ? " +
                    "ORDER BY ss.start_time DESC " +
                    "LIMIT ?";
        
        List<ScanResult.ScanSummary> history = new ArrayList<>();
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, rootGroupId + "%");
            stmt.setInt(2, limit);
            
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    history.add(mapScanSummary(rs));
                }
            }
        }
        
        return history;
    }
    
    public Future<List<TrendData>> getCveTrendsAsync(String groupId, String artifactId, int monthsBack) {
        return executorService.submit(() -> getCveTrends(groupId, artifactId, monthsBack));
    }
    
    public List<TrendData> getCveTrends(String groupId, String artifactId, int monthsBack) throws SQLException {
        // Use cached results if available
        String cacheKey = String.format("trends_%s_%s_%d", groupId, artifactId, monthsBack);
        @SuppressWarnings("unchecked")
        List<TrendData> cached = (List<TrendData>) cache.get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        String sql = "SELECT PARSEDATETIME(YEAR(ss.start_time) || '-' || MONTH(ss.start_time) || '-01', 'yyyy-M-dd') as scan_month, " +
                    "COUNT(DISTINCT sv.vulnerability_id) as vulnerability_count, " +
                    "SUM(CASE WHEN ss.critical_count > 0 THEN 1 ELSE 0 END) as critical_count, " +
                    "SUM(CASE WHEN ss.high_count > 0 THEN 1 ELSE 0 END) as high_count, " +
                    "SUM(CASE WHEN ss.medium_count > 0 THEN 1 ELSE 0 END) as medium_count, " +
                    "SUM(CASE WHEN ss.low_count > 0 THEN 1 ELSE 0 END) as low_count " +
                    "FROM scan_sessions ss " +
                    "JOIN projects p ON ss.project_id = p.id " +
                    "LEFT JOIN scan_vulnerabilities sv ON ss.id = sv.scan_session_id " +
                    "WHERE (p.group_id = ? OR p.group_id LIKE ?) AND p.artifact_id = ? " +
                    "AND ss.start_time >= DATEADD('MONTH', -?, CURRENT_DATE()) " +
                    "GROUP BY PARSEDATETIME(YEAR(ss.start_time) || '-' || MONTH(ss.start_time) || '-01', 'yyyy-M-dd') " +
                    "ORDER BY scan_month ASC";
        
        List<TrendData> trends = new ArrayList<>();
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, groupId);
            stmt.setString(2, groupId + ".%"); // Support for multi-module projects
            stmt.setString(3, artifactId);
            stmt.setInt(4, monthsBack);
            
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    TrendData trend = new TrendData();
                    trend.setPeriod(rs.getDate("scan_month").toLocalDate());
                    trend.setTotalVulnerabilities(rs.getInt("vulnerability_count"));
                    trend.setCriticalCount(rs.getInt("critical_count"));
                    trend.setHighCount(rs.getInt("high_count"));
                    trend.setMediumCount(rs.getInt("medium_count"));
                    trend.setLowCount(rs.getInt("low_count"));
                    trends.add(trend);
                }
            }
        }
        
        // Cache results for 1 hour
        cache.put(cacheKey, trends);
        
        return trends;
    }
    
    // Other existing methods with performance improvements...
    private Long storeProject(Connection conn, ScanResult result) throws SQLException {
        // Implementation with ON CONFLICT handling for better performance
        String upsertSql = "MERGE INTO projects (group_id, artifact_id, version, name, description, updated_at) " +
                          "KEY(group_id, artifact_id, version) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)";
        
        try (PreparedStatement stmt = conn.prepareStatement(upsertSql, Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, result.getProjectGroupId());
            stmt.setString(2, result.getProjectArtifactId());
            stmt.setString(3, result.getProjectVersion());
            stmt.setString(4, result.getProjectName());
            stmt.setString(5, result.getProjectDescription());
            stmt.executeUpdate();
            
            try (ResultSet rs = stmt.getGeneratedKeys()) {
                if (rs.next()) {
                    return rs.getLong(1);
                }
            }
        }
        
        // Fallback to SELECT if MERGE failed
        String selectSql = "SELECT id FROM projects WHERE group_id = ? AND artifact_id = ? AND version = ?";
        try (PreparedStatement stmt = conn.prepareStatement(selectSql)) {
            stmt.setString(1, result.getProjectGroupId());
            stmt.setString(2, result.getProjectArtifactId());
            stmt.setString(3, result.getProjectVersion());
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getLong("id");
                }
            }
        }
        
        throw new SQLException("Failed to store/retrieve project");
    }
    
    private Long createScanSession(Connection conn, Long projectId, ScanResult result) throws SQLException {
        String sql = "INSERT INTO scan_sessions (project_id, scan_type, scanner_version, start_time, " +
                    "status, configuration) VALUES (?, ?, ?, ?, ?, ?)";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            stmt.setLong(1, projectId);
            stmt.setString(2, result.getScanType() != null ? result.getScanType() : "FULL");
            stmt.setString(3, "1.0.0");
            stmt.setTimestamp(4, Timestamp.valueOf(result.getStartTime()));
            stmt.setString(5, "COMPLETED");
            stmt.setString(6, result.getConfigurationJson());
            stmt.executeUpdate();
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    return generatedKeys.getLong(1);
                } else {
                    throw new SQLException("Failed to get generated scan session ID");
                }
            }
        }
    }
    
    private void updateScanSession(Connection conn, Long scanSessionId, ScanResult result) throws SQLException {
        String sql = "UPDATE scan_sessions SET end_time = ?, total_dependencies = ?, " +
                    "vulnerable_dependencies = ?, total_vulnerabilities = ?, " +
                    "critical_count = ?, high_count = ?, medium_count = ?, low_count = ? " +
                    "WHERE id = ?";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setTimestamp(1, Timestamp.valueOf(result.getEndTime()));
            stmt.setInt(2, result.getTotalDependencies());
            stmt.setInt(3, result.getVulnerableDependencies());
            stmt.setInt(4, result.getTotalVulnerabilities());
            stmt.setInt(5, result.getCriticalVulnerabilities());
            stmt.setInt(6, result.getHighVulnerabilities());
            stmt.setInt(7, result.getMediumVulnerabilities());
            stmt.setInt(8, result.getLowVulnerabilities());
            stmt.setLong(9, scanSessionId);
            stmt.executeUpdate();
        }
    }
    
    public void close() {
        executorService.shutdown();
        cache.clear();
        log.info("Bastion vulnerability database closed");
    }
    
    private ScanResult.ScanSummary mapScanSummary(ResultSet rs) throws SQLException {
        ScanResult.ScanSummary summary = new ScanResult.ScanSummary();
        summary.setScanId(rs.getLong("id"));
        summary.setProjectGroupId(rs.getString("group_id"));
        summary.setProjectArtifactId(rs.getString("artifact_id"));
        summary.setProjectVersion(rs.getString("version"));
        summary.setProjectName(rs.getString("name"));
        summary.setScanType(rs.getString("scan_type"));
        summary.setStartTime(rs.getTimestamp("start_time").toLocalDateTime());
        
        Timestamp endTime = rs.getTimestamp("end_time");
        if (endTime != null) {
            summary.setEndTime(endTime.toLocalDateTime());
        }
        
        summary.setStatus(rs.getString("status"));
        summary.setTotalDependencies(rs.getInt("total_dependencies"));
        summary.setVulnerableDependencies(rs.getInt("vulnerable_dependencies"));
        summary.setTotalVulnerabilities(rs.getInt("total_vulnerabilities"));
        summary.setCriticalCount(rs.getInt("critical_count"));
        summary.setHighCount(rs.getInt("high_count"));
        summary.setMediumCount(rs.getInt("medium_count"));
        summary.setLowCount(rs.getInt("low_count"));
        
        return summary;
    }
    
    // Purge operations for database cleanup
    public int countAllScanResults() throws SQLException {
        String sql = "SELECT COUNT(*) FROM scan_results";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            
            if (rs.next()) {
                return rs.getInt(1);
            }
            return 0;
        }
    }
    
    public int countAllVulnerabilities() throws SQLException {
        String sql = "SELECT COUNT(*) FROM vulnerabilities";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            
            if (rs.next()) {
                return rs.getInt(1);
            }
            return 0;
        }
    }
    
    public int countDistinctProjects() throws SQLException {
        String sql = "SELECT COUNT(DISTINCT CONCAT(project_group_id, ':', project_artifact_id)) FROM scan_results";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            
            if (rs.next()) {
                return rs.getInt(1);
            }
            return 0;
        }
    }
    
    public int countScanResultsForProject(String groupId, String artifactId) throws SQLException {
        String sql = "SELECT COUNT(*) FROM scan_results WHERE project_group_id = ? AND project_artifact_id = ?";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, groupId);
            stmt.setString(2, artifactId);
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt(1);
                }
                return 0;
            }
        }
    }
    
    public int countVulnerabilitiesForProject(String groupId, String artifactId) throws SQLException {
        String sql = "SELECT COUNT(DISTINCT v.id) FROM vulnerabilities v " +
                    "INNER JOIN scan_result_vulnerabilities srv ON v.id = srv.vulnerability_id " +
                    "INNER JOIN scan_results sr ON srv.scan_result_id = sr.id " +
                    "WHERE sr.project_group_id = ? AND sr.project_artifact_id = ?";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, groupId);
            stmt.setString(2, artifactId);
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt(1);
                }
                return 0;
            }
        }
    }
    
    public int countScanResultsOlderThan(int days) throws SQLException {
        String sql = "SELECT COUNT(*) FROM scan_results WHERE start_time < ?";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(days);
            stmt.setTimestamp(1, Timestamp.valueOf(cutoffDate));
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt(1);
                }
                return 0;
            }
        }
    }
    
    public int countVulnerabilitiesOlderThan(int days) throws SQLException {
        String sql = "SELECT COUNT(DISTINCT v.id) FROM vulnerabilities v " +
                    "INNER JOIN scan_result_vulnerabilities srv ON v.id = srv.vulnerability_id " +
                    "INNER JOIN scan_results sr ON srv.scan_result_id = sr.id " +
                    "WHERE sr.start_time < ?";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(days);
            stmt.setTimestamp(1, Timestamp.valueOf(cutoffDate));
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt(1);
                }
                return 0;
            }
        }
    }
    
    public int deleteAllScanResults() throws SQLException {
        // Delete in correct order to maintain referential integrity
        String[] deleteSqls = {
            "DELETE FROM scan_result_vulnerabilities",
            "DELETE FROM scan_result_dependencies", 
            "DELETE FROM scan_result_performance_metrics",
            "DELETE FROM scan_result_statistics",
            "DELETE FROM scan_results"
        };
        
        int totalDeleted = 0;
        
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            
            try {
                for (String sql : deleteSqls) {
                    try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                        int deleted = stmt.executeUpdate();
                        if (sql.endsWith("scan_results")) {
                            totalDeleted = deleted; // Only count actual scan results
                        }
                    }
                }
                conn.commit();
                log.info("Deleted all scan results and related data");
                
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        }
        
        return totalDeleted;
    }
    
    public int deleteAllVulnerabilities() throws SQLException {
        String sql = "DELETE FROM vulnerabilities WHERE id NOT IN " +
                    "(SELECT DISTINCT vulnerability_id FROM scan_result_vulnerabilities)";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            int deleted = stmt.executeUpdate();
            log.info("Deleted {} orphaned vulnerability records", deleted);
            return deleted;
        }
    }
    
    public int deleteAllStatistics() throws SQLException {
        String sql = "DELETE FROM scan_result_statistics";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            int deleted = stmt.executeUpdate();
            log.info("Deleted {} statistics records", deleted);
            return deleted;
        }
    }
    
    public int deleteAllPerformanceMetrics() throws SQLException {
        String sql = "DELETE FROM scan_result_performance_metrics";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            int deleted = stmt.executeUpdate();
            log.info("Deleted {} performance metrics records", deleted);
            return deleted;
        }
    }
    
    public int deleteScanResultsForProject(String groupId, String artifactId) throws SQLException {
        String sql = "DELETE FROM scan_results WHERE project_group_id = ? AND project_artifact_id = ?";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, groupId);
            stmt.setString(2, artifactId);
            
            int deleted = stmt.executeUpdate();
            log.info("Deleted {} scan results for project {}:{}", deleted, groupId, artifactId);
            return deleted;
        }
    }
    
    public int deleteVulnerabilitiesForProject(String groupId, String artifactId) throws SQLException {
        // This will be handled automatically by foreign key cascade when scan results are deleted
        String sql = "SELECT COUNT(DISTINCT srv.vulnerability_id) FROM scan_result_vulnerabilities srv " +
                    "INNER JOIN scan_results sr ON srv.scan_result_id = sr.id " +
                    "WHERE sr.project_group_id = ? AND sr.project_artifact_id = ?";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, groupId);
            stmt.setString(2, artifactId);
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    int count = rs.getInt(1);
                    log.info("Will cascade delete {} vulnerability associations for project {}:{}", 
                              count, groupId, artifactId);
                    return count;
                }
                return 0;
            }
        }
    }
    
    public int deleteScanResultsOlderThan(int days) throws SQLException {
        String sql = "DELETE FROM scan_results WHERE start_time < ?";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(days);
            stmt.setTimestamp(1, Timestamp.valueOf(cutoffDate));
            
            int deleted = stmt.executeUpdate();
            log.info("Deleted {} scan results older than {} days", deleted, days);
            return deleted;
        }
    }
    
    public int deleteVulnerabilitiesOlderThan(int days) throws SQLException {
        // Count vulnerabilities that will be cascade deleted
        String countSql = "SELECT COUNT(DISTINCT srv.vulnerability_id) FROM scan_result_vulnerabilities srv " +
                         "INNER JOIN scan_results sr ON srv.scan_result_id = sr.id " +
                         "WHERE sr.start_time < ?";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(countSql)) {
            
            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(days);
            stmt.setTimestamp(1, Timestamp.valueOf(cutoffDate));
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    int count = rs.getInt(1);
                    log.info("Will cascade delete {} vulnerability associations older than {} days", 
                              count, days);
                    return count;
                }
                return 0;
            }
        }
    }
    
    public void optimizeDatabase() throws SQLException {
        try (Connection conn = dataSource.getConnection()) {
            String dbUrl = conn.getMetaData().getURL().toLowerCase();
            
            if (dbUrl.contains("h2")) {
                // H2 database optimization
                try (PreparedStatement stmt = conn.prepareStatement("ANALYZE")) {
                    stmt.executeUpdate();
                }
                log.info("H2 database analyzed and optimized");
                
            } else if (dbUrl.contains("postgresql")) {
                // PostgreSQL optimization
                try (PreparedStatement stmt = conn.prepareStatement("VACUUM ANALYZE")) {
                    stmt.executeUpdate();
                }
                log.info("PostgreSQL database vacuumed and analyzed");
                
            } else if (dbUrl.contains("mysql")) {
                // MySQL optimization
                try (PreparedStatement stmt = conn.prepareStatement("OPTIMIZE TABLE scan_results, vulnerabilities")) {
                    stmt.executeUpdate();
                }
                log.info("MySQL tables optimized");
            }
        }
    }

    // Data classes
    public static class TrendData {
        private LocalDate period;
        private int totalVulnerabilities;
        private int criticalCount;
        private int highCount;
        private int mediumCount;
        private int lowCount;
        private int vulnerableJarCount;
        
        // Getters and setters
        public LocalDate getPeriod() { return period; }
        public void setPeriod(LocalDate period) { this.period = period; }
        
        public int getTotalVulnerabilities() { return totalVulnerabilities; }
        public void setTotalVulnerabilities(int totalVulnerabilities) { this.totalVulnerabilities = totalVulnerabilities; }
        
        public int getCriticalCount() { return criticalCount; }
        public void setCriticalCount(int criticalCount) { this.criticalCount = criticalCount; }
        
        public int getHighCount() { return highCount; }
        public void setHighCount(int highCount) { this.highCount = highCount; }
        
        public int getMediumCount() { return mediumCount; }
        public void setMediumCount(int mediumCount) { this.mediumCount = mediumCount; }
        
        public int getLowCount() { return lowCount; }
        public void setLowCount(int lowCount) { this.lowCount = lowCount; }
        
        public int getVulnerableJarCount() { return vulnerableJarCount; }
        public void setVulnerableJarCount(int vulnerableJarCount) { this.vulnerableJarCount = vulnerableJarCount; }
    }
    
    public static class ImpactedJarReport {
        private String groupId;
        private String artifactId;
        private String version;
        private String scope;
        private boolean direct;
        private int vulnerabilityCount;
        private List<String> vulnerabilityIds;
        private String filePath;
        private Long fileSize;
        
        // Getters and setters
        public String getGroupId() { return groupId; }
        public void setGroupId(String groupId) { this.groupId = groupId; }
        
        public String getArtifactId() { return artifactId; }
        public void setArtifactId(String artifactId) { this.artifactId = artifactId; }
        
        public String getVersion() { return version; }
        public void setVersion(String version) { this.version = version; }
        
        public String getScope() { return scope; }
        public void setScope(String scope) { this.scope = scope; }
        
        public boolean isDirect() { return direct; }
        public void setDirect(boolean direct) { this.direct = direct; }
        
        public int getVulnerabilityCount() { return vulnerabilityCount; }
        public void setVulnerabilityCount(int vulnerabilityCount) { this.vulnerabilityCount = vulnerabilityCount; }
        
        public List<String> getVulnerabilityIds() { return vulnerabilityIds; }
        public void setVulnerabilityIds(List<String> vulnerabilityIds) { this.vulnerabilityIds = vulnerabilityIds; }
        
        public String getFilePath() { return filePath; }
        public void setFilePath(String filePath) { this.filePath = filePath; }
        
        public Long getFileSize() { return fileSize; }
        public void setFileSize(Long fileSize) { this.fileSize = fileSize; }
        
        public String getCoordinates() {
            return groupId + ":" + artifactId + ":" + version;
        }
    }
    
    // Configuration classes
    public static class DatabaseConfig {
        private String type = "h2";
        private String url;
        private String path;
        private String username;
        private String password;
        
        // Getters and setters
        public String getType() { return type; }
        public void setType(String type) { this.type = type; }
        
        public String getUrl() { return url; }
        public void setUrl(String url) { this.url = url; }
        
        public String getPath() { return path; }
        public void setPath(String path) { this.path = path; }
        
        public String getUsername() { return username; }
        public void setUsername(String username) { this.username = username; }
        
        public String getPassword() { return password; }
        public void setPassword(String password) { this.password = password; }
    }
    
    // High-performance DataSource implementation
    private static class PerformantDataSource implements DataSource {
        private final String url;
        private final String username;
        private final String password;
        
        public PerformantDataSource(String url, String username, String password) {
            this.url = url;
            this.username = username;
            this.password = password;
        }
        
        @Override
        public Connection getConnection() throws SQLException {
            Properties props = new Properties();
            if (username != null) props.setProperty("user", username);
            if (password != null) props.setProperty("password", password);
            
            Connection conn = DriverManager.getConnection(url, props);
            
            // Optimize connection for performance
            if (url.startsWith("jdbc:h2:")) {
                try (Statement stmt = conn.createStatement()) {
                    stmt.execute("SET LOCK_TIMEOUT 10000");
                    stmt.execute("SET DEFAULT_LOCK_TIMEOUT 10000");
                }
            }
            
            return conn;
        }
        
        @Override
        public Connection getConnection(String username, String password) throws SQLException {
            Properties props = new Properties();
            props.setProperty("user", username);
            props.setProperty("password", password);
            return DriverManager.getConnection(url, props);
        }
        
        // Other DataSource methods with default implementations
        @Override public java.io.PrintWriter getLogWriter() { return null; }
        @Override public void setLogWriter(java.io.PrintWriter out) {}
        @Override public void setLoginTimeout(int seconds) {}
        @Override public int getLoginTimeout() { return 0; }
        @Override public java.util.logging.Logger getParentLogger() { return null; }
        @Override public <T> T unwrap(Class<T> iface) { return null; }
        @Override public boolean isWrapperFor(Class<?> iface) { return false; }
    }
}