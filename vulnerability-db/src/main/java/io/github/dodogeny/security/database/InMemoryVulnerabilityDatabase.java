package io.github.dodogeny.security.database;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import io.github.dodogeny.security.model.ScanResult;
import org.slf4j.Logger;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Fast in-memory vulnerability database for community edition.
 * Provides temporary session-based storage with automatic cleanup.
 */
public class InMemoryVulnerabilityDatabase {
    
    private final Logger log;
    private final ObjectMapper objectMapper;
    private final Map<String, ProjectData> projects = new ConcurrentHashMap<>();
    private final Map<Long, ScanSession> sessions = new ConcurrentHashMap<>();
    private final long sessionIdCounter = System.currentTimeMillis();
    
    // Configurable limits for memory usage
    private static final int MAX_PROJECTS = 50;
    private static final int MAX_SESSIONS_PER_PROJECT = 10;
    private static final int MAX_TOTAL_SESSIONS = 100;
    private static final long SESSION_TTL_HOURS = 24;
    
    public InMemoryVulnerabilityDatabase(Logger log) {
        this.log = log;
        this.objectMapper = new ObjectMapper();
        this.objectMapper.registerModule(new JavaTimeModule());
        log.info("üöÄ Initialized in-memory vulnerability database (Community Edition)");
        log.info("   ‚Ä¢ Session-based storage with automatic cleanup");
        log.info("   ‚Ä¢ Maximum {} projects, {} sessions per project", MAX_PROJECTS, MAX_SESSIONS_PER_PROJECT);
    }
    
    /**
     * Store scan result in memory with automatic cleanup
     */
    public void storeScanResult(ScanResult result) {
        String projectKey = getProjectKey(result);
        
        // Clean up old data if needed
        cleanupOldSessions();
        enforceMemoryLimits();
        
        // Get or create project data
        ProjectData projectData = projects.computeIfAbsent(projectKey, k -> {
            ProjectData pd = new ProjectData();
            pd.groupId = result.getProjectGroupId();
            pd.artifactId = result.getProjectArtifactId();
            pd.name = result.getProjectName();
            pd.sessions = new ArrayList<>();
            return pd;
        });
        
        // Create scan session
        ScanSession session = new ScanSession();
        session.id = System.currentTimeMillis() + projects.size();
        session.projectKey = projectKey;
        session.startTime = result.getStartTime();
        session.endTime = result.getEndTime();
        session.totalVulnerabilities = result.getTotalVulnerabilities();
        session.totalDependencies = result.getTotalDependencies();
        session.vulnerableDependencies = result.getVulnerableDependencies();
        session.criticalCount = result.getCriticalVulnerabilities();
        session.highCount = result.getHighVulnerabilities();
        session.mediumCount = result.getMediumVulnerabilities();
        session.lowCount = result.getLowVulnerabilities();
        session.scanResult = result; // Keep full result for recent sessions
        session.createdAt = LocalDateTime.now();
        
        // Warn when approaching per-project session limit
        if (projectData.sessions.size() >= MAX_SESSIONS_PER_PROJECT - 2 &&
            projectData.sessions.size() < MAX_SESSIONS_PER_PROJECT) {
            log.warn("");
            log.warn("‚ö†Ô∏è  Project '{}' has {}/{} scan sessions", projectKey,
                    projectData.sessions.size(), MAX_SESSIONS_PER_PROJECT);
            log.warn("   Oldest scans will be automatically deleted when limit is reached.");
            log.warn("");
            log.warn("üí° Enterprise Edition:");
            log.warn("   ‚úì Unlimited scan history per project");
            log.warn("   ‚úì PostgreSQL/MySQL database storage");
            log.warn("   ‚úì Historical trend analysis across months/years");
            log.warn("   ‚Üí Never lose scan data ($89/month): https://bastion-plugin.lemonsqueezy.com/checkout");
            log.warn("");
        }

        // Add to project sessions (maintain limit)
        projectData.sessions.add(session);
        if (projectData.sessions.size() > MAX_SESSIONS_PER_PROJECT) {
            // Remove oldest session
            ScanSession removed = projectData.sessions.remove(0);
            sessions.remove(removed.id);
            log.warn("üóëÔ∏è  Removed oldest scan session for project '{}' (Community Edition limit: {} sessions)",
                    projectKey, MAX_SESSIONS_PER_PROJECT);
        }

        // Add to global sessions
        sessions.put(session.id, session);

        log.info("üìä Stored scan result in memory: {} (session: {}, {} vulnerabilities)",
                projectKey, session.id, result.getTotalVulnerabilities());
    }
    
    /**
     * Get recent scan history for a project
     */
    public List<ScanSummary> getScanHistory(String groupId, String artifactId, int limit) {
        String projectKey = groupId + ":" + artifactId;
        ProjectData projectData = projects.get(projectKey);
        
        if (projectData == null || projectData.sessions.isEmpty()) {
            return new ArrayList<>();
        }
        
        return projectData.sessions.stream()
                .sorted((a, b) -> b.startTime.compareTo(a.startTime))
                .limit(limit)
                .map(this::convertToSummary)
                .collect(Collectors.toList());
    }
    
    /**
     * Get basic project statistics
     */
    public ProjectStats getProjectStats(String groupId, String artifactId) {
        String projectKey = groupId + ":" + artifactId;
        ProjectData projectData = projects.get(projectKey);
        
        if (projectData == null || projectData.sessions.isEmpty()) {
            return new ProjectStats(0, 0, 0, null, null);
        }
        
        List<ScanSession> sessions = projectData.sessions;
        ScanSession latest = sessions.get(sessions.size() - 1);
        ScanSession previous = sessions.size() > 1 ? sessions.get(sessions.size() - 2) : null;
        
        int totalScans = sessions.size();
        int totalVulns = latest.totalVulnerabilities;
        int trend = previous != null ? totalVulns - previous.totalVulnerabilities : 0;
        
        return new ProjectStats(totalScans, totalVulns, trend, latest.startTime, previous != null ? previous.startTime : null);
    }
    
    /**
     * Get all projects with scan data
     */
    public List<ProjectInfo> getAllProjects() {
        return projects.entrySet().stream()
                .map(entry -> {
                    ProjectData pd = entry.getValue();
                    ScanSession latest = pd.sessions.isEmpty() ? null : pd.sessions.get(pd.sessions.size() - 1);
                    return new ProjectInfo(
                        pd.groupId, 
                        pd.artifactId, 
                        pd.name,
                        pd.sessions.size(),
                        latest != null ? latest.totalVulnerabilities : 0,
                        latest != null ? latest.startTime : null
                    );
                })
                .sorted((a, b) -> {
                    if (a.lastScanTime == null) return 1;
                    if (b.lastScanTime == null) return -1;
                    return b.lastScanTime.compareTo(a.lastScanTime);
                })
                .collect(Collectors.toList());
    }
    
    /**
     * Export data as JSON for persistence between sessions
     */
    public String exportAsJson() {
        try {
            Map<String, Object> export = new HashMap<>();
            export.put("exportTime", LocalDateTime.now());
            export.put("projects", projects);
            export.put("sessionCount", sessions.size());
            export.put("version", "1.0");
            
            return objectMapper.writeValueAsString(export);
        } catch (Exception e) {
            log.error("Failed to export data as JSON", e);
            return "{}";
        }
    }
    
    /**
     * Import data from JSON
     */
    public void importFromJson(String json) {
        try {
            if (json == null || json.trim().isEmpty() || json.equals("{}")) {
                return;
            }
            
            @SuppressWarnings("unchecked")
            Map<String, Object> imported = objectMapper.readValue(json, Map.class);
            
            @SuppressWarnings("unchecked")
            Map<String, Object> importedProjects = (Map<String, Object>) imported.get("projects");
            
            if (importedProjects != null) {
                // Note: This is a simplified import - in production you'd want proper deserialization
                log.info("üì• Imported {} projects from JSON data", importedProjects.size());
            }
        } catch (Exception e) {
            log.warn("Failed to import JSON data, starting with clean state", e);
        }
    }
    
    /**
     * Clear all data
     */
    public void clearAll() {
        projects.clear();
        sessions.clear();
        log.info("üßπ Cleared all in-memory data");
    }
    
    /**
     * Get total scan count across all projects (for usage tracking)
     */
    public int getTotalScanCount() {
        return sessions.size();
    }

    /**
     * Get scan count for a specific project
     */
    public int getScanCountForProject(String groupId, String artifactId) {
        String projectKey = groupId + ":" + artifactId;
        ProjectData projectData = projects.get(projectKey);
        return projectData != null ? projectData.sessions.size() : 0;
    }

    /**
     * Get memory usage statistics
     */
    public MemoryStats getMemoryStats() {
        int totalSessions = sessions.size();
        long memoryUsed = estimateMemoryUsage();

        return new MemoryStats(
            projects.size(),
            totalSessions,
            memoryUsed,
            MAX_PROJECTS,
            MAX_TOTAL_SESSIONS
        );
    }
    
    private void cleanupOldSessions() {
        LocalDateTime cutoff = LocalDateTime.now().minusHours(SESSION_TTL_HOURS);
        
        sessions.entrySet().removeIf(entry -> {
            ScanSession session = entry.getValue();
            return session.createdAt.isBefore(cutoff);
        });
        
        // Clean up project sessions too
        for (ProjectData pd : projects.values()) {
            pd.sessions.removeIf(session -> session.createdAt.isBefore(cutoff));
        }
        
        // Remove empty projects
        projects.entrySet().removeIf(entry -> entry.getValue().sessions.isEmpty());
    }
    
    private void enforceMemoryLimits() {
        // Warn when approaching project limit (show upgrade message early)
        if (projects.size() >= MAX_PROJECTS - 5 && projects.size() < MAX_PROJECTS) {
            log.warn("");
            log.warn("‚ö†Ô∏è  Approaching memory limits ({}/{} projects)", projects.size(), MAX_PROJECTS);
            log.warn("   Oldest projects will be automatically deleted when limit is reached.");
            log.warn("");
            log.warn("üí° Enterprise Edition offers:");
            log.warn("   ‚úì Unlimited projects (no 50-project limit)");
            log.warn("   ‚úì Persistent database storage (PostgreSQL, MySQL, H2)");
            log.warn("   ‚úì Full scan history across all projects");
            log.warn("   ‚Üí Upgrade now ($89/month): https://bastion-plugin.lemonsqueezy.com/checkout");
            log.warn("");
        }

        // If we have too many projects, remove the oldest ones
        if (projects.size() > MAX_PROJECTS) {
            List<Map.Entry<String, ProjectData>> sorted = projects.entrySet().stream()
                    .sorted((a, b) -> {
                        LocalDateTime aTime = a.getValue().sessions.isEmpty() ? LocalDateTime.MIN :
                                             a.getValue().sessions.get(a.getValue().sessions.size() - 1).startTime;
                        LocalDateTime bTime = b.getValue().sessions.isEmpty() ? LocalDateTime.MIN :
                                             b.getValue().sessions.get(b.getValue().sessions.size() - 1).startTime;
                        return aTime.compareTo(bTime);
                    })
                    .collect(Collectors.toList());

            int toRemove = projects.size() - MAX_PROJECTS + 5; // Remove a few extra for buffer
            for (int i = 0; i < toRemove && i < sorted.size(); i++) {
                String key = sorted.get(i).getKey();
                ProjectData removed = projects.remove(key);
                if (removed != null) {
                    for (ScanSession session : removed.sessions) {
                        sessions.remove(session.id);
                    }
                }
            }

            log.warn("üßπ Cleaned up {} old projects to enforce memory limits (Community Edition)", toRemove);
            log.warn("üíº Enterprise Edition: Never lose data with persistent database storage");
            log.warn("   ‚Üí Upgrade now ($89/month): https://bastion-plugin.lemonsqueezy.com/checkout");
        }
        
        // If we have too many total sessions, clean up the oldest ones
        if (sessions.size() > MAX_TOTAL_SESSIONS) {
            List<ScanSession> sorted = sessions.values().stream()
                    .sorted((a, b) -> a.createdAt.compareTo(b.createdAt))
                    .collect(Collectors.toList());
            
            int toRemove = sessions.size() - MAX_TOTAL_SESSIONS + 10; // Remove extra for buffer
            for (int i = 0; i < toRemove && i < sorted.size(); i++) {
                ScanSession session = sorted.get(i);
                sessions.remove(session.id);
                
                // Also remove from project data
                ProjectData pd = projects.get(session.projectKey);
                if (pd != null) {
                    pd.sessions.removeIf(s -> s.id == session.id);
                }
            }
            
            log.info("üßπ Cleaned up {} old sessions to enforce memory limits", toRemove);
        }
    }
    
    private long estimateMemoryUsage() {
        // Rough estimate of memory usage
        long projectsMemory = projects.size() * 1024; // ~1KB per project
        long sessionsMemory = sessions.size() * 5120; // ~5KB per session
        return projectsMemory + sessionsMemory;
    }
    
    private String getProjectKey(ScanResult result) {
        return result.getProjectGroupId() + ":" + result.getProjectArtifactId();
    }
    
    private ScanSummary convertToSummary(ScanSession session) {
        ScanSummary summary = new ScanSummary();
        summary.sessionId = session.id;
        summary.startTime = session.startTime;
        summary.endTime = session.endTime;
        summary.totalVulnerabilities = session.totalVulnerabilities;
        summary.totalDependencies = session.totalDependencies;
        summary.vulnerableDependencies = session.vulnerableDependencies;
        summary.criticalCount = session.criticalCount;
        summary.highCount = session.highCount;
        summary.mediumCount = session.mediumCount;
        summary.lowCount = session.lowCount;
        return summary;
    }
    
    // Data classes
    private static class ProjectData {
        String groupId;
        String artifactId;
        String name;
        List<ScanSession> sessions;
    }
    
    private static class ScanSession {
        long id;
        String projectKey;
        LocalDateTime startTime;
        LocalDateTime endTime;
        int totalVulnerabilities;
        int totalDependencies;
        int vulnerableDependencies;
        int criticalCount;
        int highCount;
        int mediumCount;
        int lowCount;
        ScanResult scanResult; // Full result for recent sessions
        LocalDateTime createdAt;
    }
    
    // Public data classes
    public static class ScanSummary {
        public long sessionId;
        public LocalDateTime startTime;
        public LocalDateTime endTime;
        public int totalVulnerabilities;
        public int totalDependencies;
        public int vulnerableDependencies;
        public int criticalCount;
        public int highCount;
        public int mediumCount;
        public int lowCount;
    }
    
    public static class ProjectStats {
        public final int totalScans;
        public final int currentVulnerabilities;
        public final int vulnerabilityTrend; // positive = increase, negative = decrease
        public final LocalDateTime lastScanTime;
        public final LocalDateTime previousScanTime;
        
        public ProjectStats(int totalScans, int currentVulnerabilities, int vulnerabilityTrend, 
                           LocalDateTime lastScanTime, LocalDateTime previousScanTime) {
            this.totalScans = totalScans;
            this.currentVulnerabilities = currentVulnerabilities;
            this.vulnerabilityTrend = vulnerabilityTrend;
            this.lastScanTime = lastScanTime;
            this.previousScanTime = previousScanTime;
        }
    }
    
    public static class ProjectInfo {
        public final String groupId;
        public final String artifactId;
        public final String name;
        public final int scanCount;
        public final int lastVulnerabilityCount;
        public final LocalDateTime lastScanTime;
        
        public ProjectInfo(String groupId, String artifactId, String name, 
                          int scanCount, int lastVulnerabilityCount, LocalDateTime lastScanTime) {
            this.groupId = groupId;
            this.artifactId = artifactId;
            this.name = name;
            this.scanCount = scanCount;
            this.lastVulnerabilityCount = lastVulnerabilityCount;
            this.lastScanTime = lastScanTime;
        }
    }
    
    public static class MemoryStats {
        public final int projectCount;
        public final int sessionCount;
        public final long estimatedMemoryUsage;
        public final int maxProjects;
        public final int maxSessions;
        
        public MemoryStats(int projectCount, int sessionCount, long estimatedMemoryUsage,
                          int maxProjects, int maxSessions) {
            this.projectCount = projectCount;
            this.sessionCount = sessionCount;
            this.estimatedMemoryUsage = estimatedMemoryUsage;
            this.maxProjects = maxProjects;
            this.maxSessions = maxSessions;
        }
        
        public String formatMemoryUsage() {
            if (estimatedMemoryUsage < 1024) {
                return estimatedMemoryUsage + " B";
            } else if (estimatedMemoryUsage < 1024 * 1024) {
                return (estimatedMemoryUsage / 1024) + " KB";
            } else {
                return (estimatedMemoryUsage / (1024 * 1024)) + " MB";
            }
        }
    }
}