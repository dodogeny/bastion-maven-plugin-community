package io.github.dodogeny.security.database;

import io.github.dodogeny.security.model.ScanResult;
import io.github.dodogeny.security.model.Vulnerability;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;

import java.io.File;
import java.nio.file.Path;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.Future;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class VulnerabilityDatabaseTest {

    @Mock
    private Logger mockLogger;

    private VulnerabilityDatabase database;
    private VulnerabilityDatabase.DatabaseConfig config;
    
    @TempDir
    private Path tempDir;

    @BeforeEach
    void setUpDatabase() throws SQLException {
        // Reset mock before each test
        reset(mockLogger);
        
        config = new VulnerabilityDatabase.DatabaseConfig();
        config.setType("h2");
        
        // Use in-memory H2 database for tests to avoid path issues
        config.setPath("mem:testdb_" + System.nanoTime() + ";DB_CLOSE_DELAY=-1");
        
        database = new VulnerabilityDatabase(config, mockLogger);
        database.initialize();
    }

    @AfterEach
    void tearDown() {
        if (database != null) {
            database.close();
        }
    }

    @Test
    @DisplayName("Should initialize H2 database successfully")
    void testDatabaseInitialization() {
        verify(mockLogger, atLeastOnce()).info(contains("Initializing"));
        verify(mockLogger, atLeastOnce()).info(contains("Database migrations completed successfully"));
    }

    @Test
    @DisplayName("Should create database directory if it doesn't exist")
    void testDatabaseDirectoryCreation() {
        VulnerabilityDatabase.DatabaseConfig newConfig = new VulnerabilityDatabase.DatabaseConfig();
        newConfig.setType("h2");
        Path dbPath = tempDir.resolve("new_test_db").resolve("subdir").resolve("db");
        newConfig.setPath(dbPath.toString());
        
        assertDoesNotThrow(() -> {
            VulnerabilityDatabase newDb = new VulnerabilityDatabase(newConfig, mockLogger);
            newDb.initialize();
            newDb.close();
        });
        
        // Check that the parent directory was created
        Path parentDir = dbPath.getParent();
        assertTrue(parentDir.toFile().exists(), "Parent directory should be created: " + parentDir);
    }

    @Test
    @DisplayName("Should store scan result with dependencies successfully")
    void testStoreScanResult() throws SQLException {
        // Create test scan result
        ScanResult scanResult = createTestScanResult();
        
        // Store the scan result
        assertDoesNotThrow(() -> database.storeScanResultBatch(scanResult));
        
        // Verify logging
        verify(mockLogger, atLeastOnce()).info(eq("Scan result stored with session ID: {} ({} dependencies processed)"), any(Long.class), any(Integer.class));
    }

    @Test
    @DisplayName("Should handle multi-module scan history correctly")
    void testMultiModuleScanHistory() throws SQLException {
        // Store multiple scan results for different modules
        storeSampleMultiModuleScans();
        
        // Test multi-module scan history
        List<ScanResult.ScanSummary> history = database.getMultiModuleScanHistory("io.github.dodogeny", 10);
        
        assertNotNull(history);
        assertFalse(history.isEmpty());
        assertTrue(history.size() >= 2);
        
        // Verify results are sorted by start time descending
        for (int i = 0; i < history.size() - 1; i++) {
            assertTrue(history.get(i).getStartTime().isAfter(history.get(i + 1).getStartTime()) ||
                      history.get(i).getStartTime().isEqual(history.get(i + 1).getStartTime()));
        }
    }

    @Test
    @DisplayName("Should generate CVE trends asynchronously")
    void testAsyncCveTrends() throws Exception {
        // Store historical scan data
        storeSampleHistoricalScans();
        
        // Test async CVE trends
        Future<List<VulnerabilityDatabase.TrendData>> future = 
            database.getCveTrendsAsync("io.github.dodogeny.test", "test-artifact", 12);
        
        assertNotNull(future);
        
        List<VulnerabilityDatabase.TrendData> trends = future.get();
        assertNotNull(trends);
        
        // Verify trends are ordered chronologically
        for (int i = 0; i < trends.size() - 1; i++) {
            assertTrue(trends.get(i).getPeriod().isBefore(trends.get(i + 1).getPeriod()) ||
                      trends.get(i).getPeriod().isEqual(trends.get(i + 1).getPeriod()));
        }
    }

    @Test
    @DisplayName("Should cache CVE trends for performance")
    void testCveTrendsCaching() throws SQLException {
        // Store sample data
        database.storeScanResultBatch(createTestScanResult());
        
        // First call - should hit database
        List<VulnerabilityDatabase.TrendData> trends1 = 
            database.getCveTrends("io.github.dodogeny.test", "test-artifact", 6);
        
        // Second call - should use cache
        List<VulnerabilityDatabase.TrendData> trends2 = 
            database.getCveTrends("io.github.dodogeny.test", "test-artifact", 6);
        
        assertEquals(trends1.size(), trends2.size());
    }

    @Test
    @DisplayName("Should handle batch processing of dependencies")
    void testBatchProcessing() throws SQLException {
        // Create scan result with many dependencies
        ScanResult scanResult = createLargeScanResult(250);
        
        long startTime = System.currentTimeMillis();
        
        assertDoesNotThrow(() -> database.storeScanResultBatch(scanResult));
        
        long duration = System.currentTimeMillis() - startTime;
        
        // Verify it completed within reasonable time (batch processing should be fast)
        assertTrue(duration < 5000, "Batch processing took too long: " + duration + "ms");
        
        verify(mockLogger, atLeastOnce()).info(eq("Scan result stored with session ID: {} ({} dependencies processed)"), any(Long.class), eq(250));
    }

    @Test
    @DisplayName("Should handle database errors gracefully")
    void testErrorHandling() {
        VulnerabilityDatabase.DatabaseConfig invalidConfig = new VulnerabilityDatabase.DatabaseConfig();
        invalidConfig.setType("invalid_type");
        
        RuntimeException exception = assertThrows(RuntimeException.class, () -> {
            new VulnerabilityDatabase(invalidConfig, mockLogger);
        });
        
        assertTrue(exception.getMessage().contains("Failed to create data source"));
    }

    @Test
    @DisplayName("Should initialize database successfully without optimization")
    void testDatabaseInitializationWithoutOptimization() throws SQLException {
        // Verify that database initialization completes successfully
        // Database optimization is now handled by migration scripts instead of runtime optimization
        verify(mockLogger, atLeastOnce()).info(contains("Database migrations completed successfully"));
        verify(mockLogger, never()).info("Database optimization completed"); // Should not run optimization
    }

    @Test
    @DisplayName("Should support PostgreSQL configuration")
    void testPostgreSQLConfig() {
        VulnerabilityDatabase.DatabaseConfig pgConfig = new VulnerabilityDatabase.DatabaseConfig();
        pgConfig.setType("postgresql");
        pgConfig.setUrl("jdbc:postgresql://localhost:5432/test_db");
        pgConfig.setUsername("test_user");
        pgConfig.setPassword("test_password");
        
        // Should not throw exception for valid PostgreSQL config
        assertDoesNotThrow(() -> {
            VulnerabilityDatabase pgDb = new VulnerabilityDatabase(pgConfig, mockLogger);
            pgDb.close();
        });
    }

    // Helper methods
    private ScanResult createTestScanResult() {
        ScanResult result = new ScanResult();
        result.setProjectGroupId("io.github.dodogeny.test");
        result.setProjectArtifactId("test-artifact");
        result.setProjectVersion("1.0.0");
        result.setProjectName("Test Project");
        result.setProjectDescription("Test project for DodoSec Scanner");
        result.setStartTime(LocalDateTime.now().minusMinutes(5));
        result.setEndTime(LocalDateTime.now());
        result.setScanType("FULL");
        result.setConfigurationJson("{\"scanners\":[\"OWASP\"]}");

        List<ScanResult.DependencyResult> dependencies = new ArrayList<>();
        
        // Add vulnerable dependency
        ScanResult.DependencyResult vulnerableDep = new ScanResult.DependencyResult();
        vulnerableDep.setGroupId("org.apache.commons");
        vulnerableDep.setArtifactId("commons-lang3");
        vulnerableDep.setVersion("3.8.1");
        vulnerableDep.setScope("compile");
        vulnerableDep.setDirect(true);
        vulnerableDep.setVulnerabilityIds(new HashSet<>(Arrays.asList("CVE-2021-1234", "CVE-2021-5678")));
        vulnerableDep.setScanTimeMs(150);
        vulnerableDep.setScannerUsed("OWASP");
        dependencies.add(vulnerableDep);
        
        // Add clean dependency
        ScanResult.DependencyResult cleanDep = new ScanResult.DependencyResult();
        cleanDep.setGroupId("org.slf4j");
        cleanDep.setArtifactId("slf4j-api");
        cleanDep.setVersion("1.7.36");
        cleanDep.setScope("compile");
        cleanDep.setDirect(true);
        cleanDep.setVulnerabilityIds(Collections.emptySet());
        cleanDep.setScanTimeMs(75);
        cleanDep.setScannerUsed("OWASP");
        dependencies.add(cleanDep);

        result.setDependencies(dependencies);
        result.setCriticalVulnerabilities(1);
        result.setHighVulnerabilities(1);
        result.setMediumVulnerabilities(0);
        result.setLowVulnerabilities(0);

        return result;
    }

    private ScanResult createLargeScanResult(int dependencyCount) {
        ScanResult result = createTestScanResult();
        List<ScanResult.DependencyResult> largeDependencies = new ArrayList<>();
        
        for (int i = 0; i < dependencyCount; i++) {
            ScanResult.DependencyResult dep = new ScanResult.DependencyResult();
            dep.setGroupId("test.group" + (i % 10));
            dep.setArtifactId("artifact-" + i);
            dep.setVersion("1.0." + i);
            dep.setScope(i % 2 == 0 ? "compile" : "test");
            dep.setDirect(i % 3 == 0);
            dep.setVulnerabilityIds(i % 5 == 0 ? Collections.singleton("CVE-2023-" + String.format("%04d", i)) : Collections.emptySet());
            dep.setScanTimeMs(50 + (i % 100));
            dep.setScannerUsed("OWASP");
            largeDependencies.add(dep);
        }
        
        result.setDependencies(largeDependencies);
        return result;
    }

    private void storeSampleMultiModuleScans() throws SQLException {
        // Module 1
        ScanResult module1 = createTestScanResult();
        module1.setProjectArtifactId("module1");
        module1.setMultiModule(true);
        module1.setRootGroupId("io.github.dodogeny");
        database.storeScanResultBatch(module1);
        
        // Module 2
        ScanResult module2 = createTestScanResult();
        module2.setProjectArtifactId("module2");
        module2.setMultiModule(true);
        module2.setRootGroupId("io.github.dodogeny");
        database.storeScanResultBatch(module2);
        
        // Different project
        ScanResult otherProject = createTestScanResult();
        otherProject.setProjectGroupId("other.company");
        otherProject.setProjectArtifactId("other-project");
        database.storeScanResultBatch(otherProject);
    }

    private void storeSampleHistoricalScans() throws SQLException {
        LocalDateTime baseTime = LocalDateTime.now().minusMonths(6);
        
        for (int i = 0; i < 6; i++) {
            ScanResult scan = createTestScanResult();
            scan.setStartTime(baseTime.plusMonths(i));
            scan.setEndTime(baseTime.plusMonths(i).plusMinutes(5));
            scan.setCriticalVulnerabilities(i % 3);
            scan.setHighVulnerabilities((i + 1) % 4);
            scan.setMediumVulnerabilities((i + 2) % 3);
            scan.setLowVulnerabilities((i + 3) % 2);
            
            database.storeScanResultBatch(scan);
        }
    }

    @Nested
    @DisplayName("Database Configuration Tests")
    class DatabaseConfigurationTest {
        
        @Test
        @DisplayName("Should handle H2 database configuration")
        void testH2Configuration() {
            VulnerabilityDatabase.DatabaseConfig config = new VulnerabilityDatabase.DatabaseConfig();
            config.setType("h2");
            config.setPath("/tmp/test.db");
            
            assertEquals("h2", config.getType());
            assertEquals("/tmp/test.db", config.getPath());
        }
        
        @Test
        @DisplayName("Should handle PostgreSQL database configuration")
        void testPostgreSQLConfiguration() {
            VulnerabilityDatabase.DatabaseConfig config = new VulnerabilityDatabase.DatabaseConfig();
            config.setType("postgresql");
            config.setUrl("jdbc:postgresql://localhost/test");
            config.setUsername("user");
            config.setPassword("pass");
            
            assertEquals("postgresql", config.getType());
            assertEquals("jdbc:postgresql://localhost/test", config.getUrl());
            assertEquals("user", config.getUsername());
            assertEquals("pass", config.getPassword());
        }
    }

    @Nested
    @DisplayName("Trend Data Tests")
    class TrendDataTest {
        
        @Test
        @DisplayName("Should create trend data correctly")
        void testTrendDataCreation() {
            VulnerabilityDatabase.TrendData trend = new VulnerabilityDatabase.TrendData();
            trend.setPeriod(LocalDateTime.now().toLocalDate());
            trend.setTotalVulnerabilities(10);
            trend.setCriticalCount(2);
            trend.setHighCount(3);
            trend.setMediumCount(4);
            trend.setLowCount(1);
            
            assertEquals(10, trend.getTotalVulnerabilities());
            assertEquals(2, trend.getCriticalCount());
            assertEquals(3, trend.getHighCount());
            assertEquals(4, trend.getMediumCount());
            assertEquals(1, trend.getLowCount());
        }
    }

    @Nested
    @DisplayName("Performance Tests")
    class PerformanceTest {
        
        @Test
        @DisplayName("Should handle concurrent database operations")
        void testConcurrentOperations() throws InterruptedException {
            List<Thread> threads = new ArrayList<>();
            List<Exception> exceptions = Collections.synchronizedList(new ArrayList<>());
            
            for (int i = 0; i < 5; i++) {
                final int threadId = i;
                Thread thread = new Thread(() -> {
                    try {
                        ScanResult result = createTestScanResult();
                        result.setProjectArtifactId("concurrent-test-" + threadId);
                        database.storeScanResultBatch(result);
                    } catch (Exception e) {
                        exceptions.add(e);
                    }
                });
                threads.add(thread);
                thread.start();
            }
            
            // Wait for all threads to complete
            for (Thread thread : threads) {
                thread.join(5000); // 5 second timeout
            }
            
            // Verify no exceptions occurred
            assertTrue(exceptions.isEmpty(), "Concurrent operations failed: " + exceptions);
        }
        
        @Test
        @DisplayName("Should maintain good performance with large datasets")
        void testLargeDatasetPerformance() throws SQLException {
            long startTime = System.currentTimeMillis();
            
            // Create and store large scan result
            ScanResult largeResult = createLargeScanResult(1000);
            database.storeScanResultBatch(largeResult);
            
            long storageTime = System.currentTimeMillis() - startTime;
            
            // Storage should complete within reasonable time
            assertTrue(storageTime < 10000, "Large dataset storage took too long: " + storageTime + "ms");
            
            // Test trend retrieval performance
            startTime = System.currentTimeMillis();
            database.getCveTrends("test.group1", "artifact-1", 12);
            long retrievalTime = System.currentTimeMillis() - startTime;
            
            assertTrue(retrievalTime < 2000, "Trend retrieval took too long: " + retrievalTime + "ms");
        }
    }
}