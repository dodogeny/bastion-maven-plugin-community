package mu.dodogeny.security.plugin;

import mu.dodogeny.security.model.ScanResult;
import mu.dodogeny.security.model.Vulnerability;
import mu.dodogeny.security.scanner.OwaspDependencyCheckScanner;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.project.MavenProject;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.lang.reflect.Field;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("Vulnerability Mapping Integration Tests")
class VulnerabilityMappingIntegrationTest {

    @Mock
    private MavenProject mockProject;

    @Mock
    private MavenSession mockSession;

    @Mock
    private Log mockLog;

    @Mock
    private OwaspDependencyCheckScanner mockScanner;

    private BastionScanMojo scanMojo;

    @TempDir
    private Path tempDir;

    @BeforeEach
    void setUp() throws Exception {
        scanMojo = new BastionScanMojo();
        
        // Configure mojo
        setPrivateField("project", mockProject);
        setPrivateField("session", mockSession);
        setPrivateField("skip", false);
        setPrivateField("failOnError", false); // Don't fail to test mapping
        setPrivateField("outputDirectory", tempDir.resolve("reports").toFile());
        setPrivateField("reportFormats", "HTML,JSON");
        setPrivateField("openSourceMode", true);
        
        scanMojo.setLog(mockLog);
        
        setupMockProject();
        setupMockSession();
    }

    @Nested
    @DisplayName("CVE ID Mapping Tests")
    class CveIdMappingTest {

        @Test
        @DisplayName("Should correctly map CVE IDs to vulnerability objects")
        void testCveIdMapping() throws Exception {
            // Create scan result with proper CVE ID mapping
            ScanResult mockScanResult = createScanResultWithCveMappingFix();
            
            // Mock scanner to return our test result
            when(mockScanner.scan(any(File.class), anyMap())).thenReturn(mockScanResult);
            
            // Execute scan through reflection (simulating internal scanner call)
            // Note: Full integration would require actual scanner setup
            
            // Verify the mapping works correctly
            Map<String, ScanResult.JarVulnerabilityInfo> vulnerableJars = mockScanResult.getVulnerableJars();
            
            assertEquals(2, vulnerableJars.size(), "Should have two vulnerable JARs");
            
            // Verify jackson-databind mapping
            ScanResult.JarVulnerabilityInfo jacksonInfo = vulnerableJars.get("jackson-databind:2.9.8");
            assertNotNull(jacksonInfo, "Should contain jackson-databind");
            assertEquals(2, jacksonInfo.getCveCount(), "Jackson should have 2 CVEs");
            assertEquals(1, jacksonInfo.getCriticalCount(), "Jackson should have 1 critical CVE");
            assertEquals(1, jacksonInfo.getHighCount(), "Jackson should have 1 high CVE");
            
            // Verify commons-lang3 mapping
            ScanResult.JarVulnerabilityInfo commonsInfo = vulnerableJars.get("commons-lang3:3.8.1");
            assertNotNull(commonsInfo, "Should contain commons-lang3");
            assertEquals(1, commonsInfo.getCveCount(), "Commons should have 1 CVE");
            assertEquals(1, commonsInfo.getMediumCount(), "Commons should have 1 medium CVE");
        }

        @Test
        @DisplayName("Should handle mixed CVE and non-CVE vulnerability IDs")
        void testMixedVulnerabilityIdMapping() throws Exception {
            ScanResult scanResult = createScanResultWithMixedVulnerabilityIds();
            
            Map<String, ScanResult.JarVulnerabilityInfo> vulnerableJars = scanResult.getVulnerableJars();
            
            assertEquals(1, vulnerableJars.size(), "Should have one vulnerable JAR");
            
            ScanResult.JarVulnerabilityInfo jarInfo = vulnerableJars.get("mixed-lib:1.0.0");
            assertNotNull(jarInfo, "Should contain mixed-lib");
            assertEquals(3, jarInfo.getCveCount(), "Should have 3 vulnerabilities (CVE + custom)");
            assertEquals(1, jarInfo.getCriticalCount(), "Should have 1 critical");
            assertEquals(1, jarInfo.getHighCount(), "Should have 1 high");
            assertEquals(1, jarInfo.getMediumCount(), "Should have 1 medium");
        }

        @Test
        @DisplayName("Should handle dependencies with no matching vulnerabilities")
        void testDependenciesWithNoMatchingVulnerabilities() throws Exception {
            ScanResult scanResult = createScanResultWithUnmatchedDependencies();
            
            Map<String, ScanResult.JarVulnerabilityInfo> vulnerableJars = scanResult.getVulnerableJars();
            
            // Should only contain JARs with actual matching vulnerabilities
            assertEquals(1, vulnerableJars.size(), "Should only have JARs with matching vulnerabilities");
            assertTrue(vulnerableJars.containsKey("matching-lib:1.0.0"), "Should contain JAR with matching vulnerability");
            assertFalse(vulnerableJars.containsKey("unmatched-lib:1.0.0"), "Should not contain JAR without matching vulnerabilities");
        }
    }

    @Nested
    @DisplayName("Trend Analysis Integration Tests")
    class TrendAnalysisIntegrationTest {

        @Test
        @DisplayName("Should generate trend analysis data for vulnerable JARs")
        void testTrendAnalysisDataGeneration() throws Exception {
            ScanResult scanResult = createScanResultWithTrendData();
            
            // Verify trend data is properly structured
            assertNotNull(scanResult.getStartTime(), "Should have start time for trend analysis");
            assertNotNull(scanResult.getEndTime(), "Should have end time for trend analysis");
            
            Map<String, ScanResult.JarVulnerabilityInfo> vulnerableJars = scanResult.getVulnerableJars();
            assertFalse(vulnerableJars.isEmpty(), "Should have vulnerable JARs for trend analysis");
            
            // Verify severity distribution for trend charts
            int totalCritical = vulnerableJars.values().stream().mapToInt(ScanResult.JarVulnerabilityInfo::getCriticalCount).sum();
            int totalHigh = vulnerableJars.values().stream().mapToInt(ScanResult.JarVulnerabilityInfo::getHighCount).sum();
            int totalMedium = vulnerableJars.values().stream().mapToInt(ScanResult.JarVulnerabilityInfo::getMediumCount).sum();
            
            assertTrue(totalCritical > 0, "Should have critical vulnerabilities for trend analysis");
            assertTrue(totalHigh > 0, "Should have high vulnerabilities for trend analysis");
            assertTrue(totalMedium > 0, "Should have medium vulnerabilities for trend analysis");
        }

        @Test
        @DisplayName("Should calculate JAR count correctly for trend charts")
        void testJarCountCalculation() throws Exception {
            ScanResult scanResult = createScanResultWithMultipleVulnerableJars();
            
            Map<String, ScanResult.JarVulnerabilityInfo> vulnerableJars = scanResult.getVulnerableJars();
            
            // Verify JAR count matches expected value for trend visualization
            assertEquals(3, vulnerableJars.size(), "Should have 3 vulnerable JARs");
            
            // Verify each JAR has proper vulnerability counts
            for (ScanResult.JarVulnerabilityInfo jarInfo : vulnerableJars.values()) {
                assertTrue(jarInfo.getCveCount() > 0, "Each vulnerable JAR should have at least one CVE");
            }
        }

        @Test
        @DisplayName("Should handle time period data for trend analysis")
        void testTimePeriodDataHandling() throws Exception {
            ScanResult scanResult = createScanResultWithTimePeriodData();
            
            // Verify time-based data is properly structured
            LocalDateTime startTime = scanResult.getStartTime();
            LocalDateTime endTime = scanResult.getEndTime();
            
            assertNotNull(startTime, "Should have start time");
            assertNotNull(endTime, "Should have end time");
            assertTrue(endTime.isAfter(startTime), "End time should be after start time");
            
            // Verify scan has data suitable for trending
            assertTrue(scanResult.getTotalVulnerabilities() > 0, "Should have vulnerabilities for trending");
            assertTrue(scanResult.getVulnerableDependencies() > 0, "Should have vulnerable dependencies");
        }
    }

    @Nested
    @DisplayName("Report Generation Integration Tests")
    class ReportGenerationIntegrationTest {

        @Test
        @DisplayName("Should generate reports with correct vulnerability mapping data")
        void testReportWithVulnerabilityMapping() throws Exception {
            ScanResult scanResult = createScanResultWithCveMappingFix();
            
            // Verify that report data structure is correct for HTML generation
            Map<String, ScanResult.JarVulnerabilityInfo> vulnerableJars = scanResult.getVulnerableJars();
            
            assertFalse(vulnerableJars.isEmpty(), "Should have vulnerable JARs data for report");
            
            // Verify each JAR has the required data for report templates
            for (Map.Entry<String, ScanResult.JarVulnerabilityInfo> entry : vulnerableJars.entrySet()) {
                String jarKey = entry.getKey();
                ScanResult.JarVulnerabilityInfo jarInfo = entry.getValue();
                
                assertNotNull(jarKey, "JAR key should not be null");
                assertTrue(jarKey.contains(":"), "JAR key should contain version separator");
                
                assertTrue(jarInfo.getCveCount() > 0, "JAR should have CVE count > 0");
                assertNotNull(jarInfo.getDescription(), "JAR should have description");
                
                // Verify vulnerability list is populated
                assertNotNull(jarInfo.getVulnerabilities(), "Should have vulnerability list");
                assertFalse(jarInfo.getVulnerabilities().isEmpty(), "Vulnerability list should not be empty");
            }
        }

        @Test
        @DisplayName("Should not display empty vulnerability sections in reports")
        void testEmptyVulnerabilitySectionHandling() throws Exception {
            ScanResult cleanScanResult = createCleanScanResult();
            
            Map<String, ScanResult.JarVulnerabilityInfo> vulnerableJars = cleanScanResult.getVulnerableJars();
            
            assertTrue(vulnerableJars.isEmpty(), "Clean scan should have no vulnerable JARs");
            assertEquals(0, cleanScanResult.getTotalVulnerabilities(), "Should have 0 total vulnerabilities");
            
            // This verifies that the 'Vulnerability Distribution Across JARs' section 
            // should not be displayed when no vulnerabilities are found
        }

        @Test
        @DisplayName("Should include JAR tooltip data for interactive charts")
        void testJarTooltipDataGeneration() throws Exception {
            ScanResult scanResult = createScanResultForTooltipTesting();
            
            Map<String, ScanResult.JarVulnerabilityInfo> vulnerableJars = scanResult.getVulnerableJars();
            
            // Verify data structure supports tooltip generation
            for (Map.Entry<String, ScanResult.JarVulnerabilityInfo> entry : vulnerableJars.entrySet()) {
                String jarKey = entry.getKey();
                ScanResult.JarVulnerabilityInfo jarInfo = entry.getValue();
                
                // Extract name and version for tooltip display
                String[] parts = jarKey.split(":");
                assertTrue(parts.length >= 2, "JAR key should have name and version");
                
                String jarName = parts[0];
                String jarVersion = parts[1];
                
                assertFalse(jarName.isEmpty(), "JAR name should not be empty");
                assertFalse(jarVersion.isEmpty(), "JAR version should not be empty");
                
                // Verify severity breakdown for tooltip
                int totalSeverities = jarInfo.getCriticalCount() + jarInfo.getHighCount() + 
                                     jarInfo.getMediumCount() + jarInfo.getLowCount();
                assertEquals(jarInfo.getCveCount(), totalSeverities, 
                           "Total severity counts should equal CVE count");
            }
        }
    }

    // Helper methods
    private void setPrivateField(String fieldName, Object value) throws Exception {
        Field field = BastionScanMojo.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(scanMojo, value);
    }

    private void setupMockProject() {
        when(mockProject.getName()).thenReturn("Test Vulnerability Mapping Project");
        when(mockProject.getGroupId()).thenReturn("com.test");
        when(mockProject.getArtifactId()).thenReturn("vulnerability-test");
        when(mockProject.getVersion()).thenReturn("1.0.0");
        when(mockProject.getBasedir()).thenReturn(tempDir.toFile());
        
        File buildDir = tempDir.resolve("target").toFile();
        buildDir.mkdirs();
        when(mockProject.getBuild()).thenReturn(mock(org.apache.maven.model.Build.class));
        when(mockProject.getBuild().getDirectory()).thenReturn(buildDir.getAbsolutePath());
    }

    private void setupMockSession() {
        when(mockSession.getTopLevelProject()).thenReturn(mockProject);
        when(mockSession.getProjects()).thenReturn(Collections.singletonList(mockProject));
    }

    private ScanResult createScanResultWithCveMappingFix() {
        ScanResult result = new ScanResult();
        result.setProjectName("Test Project");
        result.setProjectGroupId("com.test");
        result.setProjectArtifactId("vulnerability-test");
        result.setProjectVersion("1.0.0");
        result.setStartTime(LocalDateTime.now().minusMinutes(5));
        result.setEndTime(LocalDateTime.now());
        
        // Create vulnerabilities with CVE IDs
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        Vulnerability vuln1 = new Vulnerability();
        vuln1.setCveId("CVE-2021-1234");
        vuln1.setId("vuln-id-1");
        vuln1.setSeverity("CRITICAL");
        vuln1.setDescription("Critical vulnerability in Jackson");
        vulnerabilities.add(vuln1);
        
        Vulnerability vuln2 = new Vulnerability();
        vuln2.setCveId("CVE-2021-5678");
        vuln2.setId("vuln-id-2");
        vuln2.setSeverity("HIGH");
        vuln2.setDescription("High vulnerability in Jackson");
        vulnerabilities.add(vuln2);
        
        Vulnerability vuln3 = new Vulnerability();
        vuln3.setCveId("CVE-2021-9999");
        vuln3.setId("vuln-id-3");
        vuln3.setSeverity("MEDIUM");
        vuln3.setDescription("Medium vulnerability in Commons Lang");
        vulnerabilities.add(vuln3);
        
        // Create dependencies with matching CVE IDs (this is the fix)
        List<ScanResult.DependencyResult> dependencies = new ArrayList<>();
        
        ScanResult.DependencyResult dep1 = new ScanResult.DependencyResult();
        dep1.setGroupId("com.fasterxml.jackson.core");
        dep1.setArtifactId("jackson-databind");
        dep1.setVersion("2.9.8");
        dep1.setScope("compile");
        dep1.setDirect(true);
        dep1.setVulnerabilityIds(new HashSet<>(Arrays.asList("CVE-2021-1234", "CVE-2021-5678")));
        dependencies.add(dep1);
        
        ScanResult.DependencyResult dep2 = new ScanResult.DependencyResult();
        dep2.setGroupId("org.apache.commons");
        dep2.setArtifactId("commons-lang3");
        dep2.setVersion("3.8.1");
        dep2.setScope("compile");
        dep2.setDirect(true);
        dep2.setVulnerabilityIds(new HashSet<>(Collections.singletonList("CVE-2021-9999")));
        dependencies.add(dep2);
        
        result.setVulnerabilities(vulnerabilities);
        result.setDependencies(dependencies);
        
        return result;
    }

    private ScanResult createScanResultWithMixedVulnerabilityIds() {
        ScanResult result = new ScanResult();
        result.setProjectName("Mixed Vulnerability Test");
        result.setProjectGroupId("com.test");
        result.setProjectArtifactId("mixed-vuln-test");
        result.setProjectVersion("1.0.0");
        result.setStartTime(LocalDateTime.now().minusMinutes(3));
        result.setEndTime(LocalDateTime.now());
        
        // Create mixed vulnerabilities (CVE and custom)
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        Vulnerability cveVuln = new Vulnerability();
        cveVuln.setCveId("CVE-2021-0001");
        cveVuln.setId("vuln-id-1");
        cveVuln.setSeverity("CRITICAL");
        vulnerabilities.add(cveVuln);
        
        Vulnerability customVuln1 = new Vulnerability();
        customVuln1.setCveId(null); // No CVE ID, will use ID
        customVuln1.setId("CUSTOM-VULN-001");
        customVuln1.setSeverity("HIGH");
        vulnerabilities.add(customVuln1);
        
        Vulnerability customVuln2 = new Vulnerability();
        customVuln2.setCveId(null);
        customVuln2.setId("CUSTOM-VULN-002");
        customVuln2.setSeverity("MEDIUM");
        vulnerabilities.add(customVuln2);
        
        // Create dependency with mixed IDs
        List<ScanResult.DependencyResult> dependencies = new ArrayList<>();
        
        ScanResult.DependencyResult dep = new ScanResult.DependencyResult();
        dep.setGroupId("com.example");
        dep.setArtifactId("mixed-lib");
        dep.setVersion("1.0.0");
        dep.setScope("compile");
        dep.setDirect(true);
        dep.setVulnerabilityIds(new HashSet<>(Arrays.asList("CVE-2021-0001", "CUSTOM-VULN-001", "CUSTOM-VULN-002")));
        dependencies.add(dep);
        
        result.setVulnerabilities(vulnerabilities);
        result.setDependencies(dependencies);
        
        return result;
    }

    private ScanResult createScanResultWithUnmatchedDependencies() {
        ScanResult result = new ScanResult();
        result.setProjectName("Unmatched Dependency Test");
        result.setProjectGroupId("com.test");
        result.setProjectArtifactId("unmatched-test");
        result.setProjectVersion("1.0.0");
        result.setStartTime(LocalDateTime.now().minusMinutes(2));
        result.setEndTime(LocalDateTime.now());
        
        // Create vulnerability
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        Vulnerability vuln = new Vulnerability();
        vuln.setCveId("CVE-2021-1111");
        vuln.setId("vuln-id-1");
        vuln.setSeverity("HIGH");
        vulnerabilities.add(vuln);
        
        // Create dependencies - one matching, one not
        List<ScanResult.DependencyResult> dependencies = new ArrayList<>();
        
        // Matching dependency
        ScanResult.DependencyResult matchingDep = new ScanResult.DependencyResult();
        matchingDep.setGroupId("com.example");
        matchingDep.setArtifactId("matching-lib");
        matchingDep.setVersion("1.0.0");
        matchingDep.setScope("compile");
        matchingDep.setDirect(true);
        matchingDep.setVulnerabilityIds(new HashSet<>(Collections.singletonList("CVE-2021-1111")));
        dependencies.add(matchingDep);
        
        // Non-matching dependency
        ScanResult.DependencyResult unmatchedDep = new ScanResult.DependencyResult();
        unmatchedDep.setGroupId("com.example");
        unmatchedDep.setArtifactId("unmatched-lib");
        unmatchedDep.setVersion("1.0.0");
        unmatchedDep.setScope("compile");
        unmatchedDep.setDirect(true);
        unmatchedDep.setVulnerabilityIds(new HashSet<>(Collections.singletonList("CVE-2021-9999"))); // Different CVE
        dependencies.add(unmatchedDep);
        
        result.setVulnerabilities(vulnerabilities);
        result.setDependencies(dependencies);
        
        return result;
    }

    private ScanResult createScanResultWithTrendData() {
        ScanResult result = createScanResultWithCveMappingFix();
        result.setStartTime(LocalDateTime.now().minusMonths(1));
        result.setEndTime(LocalDateTime.now().minusMonths(1).plusMinutes(10));
        return result;
    }

    private ScanResult createScanResultWithMultipleVulnerableJars() {
        ScanResult result = new ScanResult();
        result.setProjectName("Multiple JARs Test");
        result.setProjectGroupId("com.test");
        result.setProjectArtifactId("multi-jar-test");
        result.setProjectVersion("1.0.0");
        result.setStartTime(LocalDateTime.now().minusMinutes(8));
        result.setEndTime(LocalDateTime.now());
        
        // Create multiple vulnerabilities
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        vulnerabilities.add(createVulnerability("CVE-2021-0001", "CRITICAL"));
        vulnerabilities.add(createVulnerability("CVE-2021-0002", "HIGH"));
        vulnerabilities.add(createVulnerability("CVE-2021-0003", "MEDIUM"));
        vulnerabilities.add(createVulnerability("CVE-2021-0004", "HIGH"));
        vulnerabilities.add(createVulnerability("CVE-2021-0005", "CRITICAL"));
        
        // Create multiple dependencies
        List<ScanResult.DependencyResult> dependencies = new ArrayList<>();
        
        // JAR 1
        ScanResult.DependencyResult dep1 = createDependency("com.example", "lib-one", "1.0.0");
        dep1.getVulnerabilityIds().addAll(Arrays.asList("CVE-2021-0001", "CVE-2021-0002"));
        dependencies.add(dep1);
        
        // JAR 2
        ScanResult.DependencyResult dep2 = createDependency("org.apache", "lib-two", "2.0.0");
        dep2.getVulnerabilityIds().add("CVE-2021-0003");
        dependencies.add(dep2);
        
        // JAR 3
        ScanResult.DependencyResult dep3 = createDependency("io.github", "lib-three", "3.0.0");
        dep3.getVulnerabilityIds().addAll(Arrays.asList("CVE-2021-0004", "CVE-2021-0005"));
        dependencies.add(dep3);
        
        result.setVulnerabilities(vulnerabilities);
        result.setDependencies(dependencies);
        
        return result;
    }

    private ScanResult createScanResultWithTimePeriodData() {
        ScanResult result = createScanResultWithCveMappingFix();
        
        // Set specific time periods for trend analysis
        LocalDateTime now = LocalDateTime.now();
        result.setStartTime(now.minusMinutes(15));
        result.setEndTime(now);
        result.setScanDurationMs(900000); // 15 minutes
        
        return result;
    }

    private ScanResult createCleanScanResult() {
        ScanResult result = new ScanResult();
        result.setProjectName("Clean Project");
        result.setProjectGroupId("com.test");
        result.setProjectArtifactId("clean-test");
        result.setProjectVersion("1.0.0");
        result.setStartTime(LocalDateTime.now().minusMinutes(2));
        result.setEndTime(LocalDateTime.now());
        
        // No vulnerabilities
        result.setVulnerabilities(new ArrayList<>());
        
        // Clean dependencies
        List<ScanResult.DependencyResult> dependencies = new ArrayList<>();
        ScanResult.DependencyResult cleanDep = createDependency("com.example", "clean-lib", "1.0.0");
        // No vulnerability IDs added
        dependencies.add(cleanDep);
        
        result.setDependencies(dependencies);
        
        return result;
    }

    private ScanResult createScanResultForTooltipTesting() {
        return createScanResultWithMultipleVulnerableJars();
    }

    private Vulnerability createVulnerability(String cveId, String severity) {
        Vulnerability vuln = new Vulnerability();
        vuln.setCveId(cveId);
        vuln.setId(cveId);
        vuln.setSeverity(severity);
        vuln.setDescription("Test vulnerability: " + cveId);
        vuln.setCvssV3Score(severity.equals("CRITICAL") ? 9.0 : 
                           severity.equals("HIGH") ? 7.0 : 
                           severity.equals("MEDIUM") ? 5.0 : 3.0);
        return vuln;
    }

    private ScanResult.DependencyResult createDependency(String groupId, String artifactId, String version) {
        ScanResult.DependencyResult dep = new ScanResult.DependencyResult();
        dep.setGroupId(groupId);
        dep.setArtifactId(artifactId);
        dep.setVersion(version);
        dep.setScope("compile");
        dep.setDirect(true);
        dep.setVulnerabilityIds(new HashSet<>());
        dep.setScanTimeMs(100);
        dep.setScannerUsed("OWASP");
        return dep;
    }
}